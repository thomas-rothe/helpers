Package
	- a (rather small) PHP library containing PHP source code
Packagist
	- is a repository for public PHP packages and is the default repo used by Composer
Composer
	- is a dependency manager
	- is used for autoloading (because it has its own autoloader)
	(- does compiler optimization)
	(- custom hooks into lifecycle events, such as application installed, updated, or first created)
	(- stability checking)
DEPENDENCY
	- applications and packages can have libraries they depend on: dependencies
	- dependencies also may have their own dependencies (and so on)
	- if you tell Composer that your application or package depends on a package,
	it will also make sure that you have all the dependencies of your dependency-package
composer.json
	- is a file you create in the root directory of your project
	- you write the packages you want into this file, the version can be a range, e.g.: any version from 2.4.X to 3.X
	- you can
		- write it manually
		- create it with: composer init
		- create or append it with: composer require somevendor/somepackage
	
	Example 1)
	a minimal composer.json only has to contain valid JSON:
		{}
		
	Example 2)
	a rather minimal composer.json only lists dependencies of your project:
		"composer require michaelKaefer/oauth2-wrike" creates:
		{
		    "require": {
			"michaelKaefer/oauth2-wrike": "^1.0"
		    }
		}
		
	Example 3)
	a more useful composer.json for a package example which
		- defines the package "symfony/process" v3.3 or higher for the package in production mode and
		- "symfony/var-dumper" for the package in development mode
		- several other infos which are mainly used by packagist.org to catalog packages
		{
			"name": "me/mypackage",
			"description": "A package to play with Composer",
			"authors": [
				{
					"name": "michaelKaefer",
					"email": "michael.kaefer@something.at"
				}
			],
			"keywords": ["testing", "playing"],
			"license": "MIT",
			"require": {
				"symfony/process": "^3.3"
			},
			"require-dev": {
				"symfony/var-dumper": "^3.3"
			}
		}
		
	Stability
		you can define branches instead of version(ranges)
		but if the branch is not stable you have to explicitly allow Composer to install it (the default stability is "stable")
			{
				"require": {
					"somevendor/somepackage": "dev-master"
				},
				"minimum-stability": "dev"
			}
	Conflicting packages
		if there are packages that do not work with your apllication or package you can prevent installing them ever
		{
			"conflict": {
				"somevendor/somepackage": "1.0.0"
			}
		}
	Suggestions
		packages that enhance your packages functionality can be suggested to users of the package while
		they install your package
		{
			"suggest": {
				"somevendor/somepackage": "1.0.0"
			}
		}
	Version rules
		exact versions				1.0.2
		wildcard			*	1.0.*			equivalent of >=1.0,<1.1
		ranges of valid versions	>	<2.0
						>=	>=1.0
						<	<1.1
						<=	<=1.0
						!=	!=1.0
						,	>=1.0,<2.0		, is like logical AND (defines multiple ranges)
						|	>=1.0,<1.1 | >=1.2	| is like logical OR
						, has higher precedence than |
		tilde operator			∼1.2				equivalent to >=1.2,<2.0.
composer.lock
	- is written automatically by Composer
	- contains all actually installed packages plus the exact version, e.g.: 2.6.13
composer install
	1. checks if the file "composer.lock" exists
	2.	- if it exists it reads it and installs the dependencies listed there
		- if not it does the same as "composer update"
composer update
	1. checks if the file "composer.json" exists
	2. reads the file and for every package it remembers the latest possible version 
	3. if the file exists it reads "composer.lock" and compares the remembered latest possible version from "composer.json" with the version currently installed
	4. if the remembered version is newer tha the one in "composer.lock" it installs the newer version
	5. creates or updates the file "composer.lock"
	
	--dev
		- braucht man nicht setzen: ist default und installiert auch alle packages unter "require-dev"
		- für die Produktivversion braucht man zB keine Tests und kann die Installation von "require-dev"-packages 
		ausschließen mit: --no-dev (diese Option löscht sogar alle zuvor installierten "require-dev"-packages 
		physisch vom Rechner)
composer require [vendorname/packagename]
	1. creates a composer.json file if it not exists
	2. in composer.json it adds the package to the "require" section (or to "require-dev" section)
	3. if it not exists creates a folder "vendor"
	4. installs the package under "vendor/"
	5. creates or updates composer.lock with the package, its version and its dependencies
Autoloading
	- by default Composer automatically creates a file "vendor/autoload"
	- if you require this file to your code you can autoload all classes of your dependencies
		<?php
		require 'vendor/autoload.php';
		use [namespace\path\to\classname];
		$var = [classname]::[method]([params]);
	- if you want to configure autoloading yourself Composer offers differten methods of autoloading
		files
			when you require "vendor/autoload.php" Composer will load a list of files
			{
				"autoload": {
					"files": [
						"projectroot/path/file.php",
						"projectroot/otherpath/file.php"
					]
				}
			}
		classmap
		psr-0
		psr-4
Lifecycle hooks and scripts
	- Composer allows you to define commands which will be run after a specified event
	- for example after composer "create-project", "composer install", "composer update" etc.
	- e.g.: in Laravel you could run your migrations, clean up assets, etc. after every "composer install", so to get to production you only run "git pull ; composer install"
	
	"scripts": {
		"post-root-package-install": [
			"php -r \"file_exists('.env') || copy('.env.example', '.env');\""
		],
		"post-create-project-cmd": [
			"php artisan key:generate"
		],
		"post-install-cmd": [
			"illuminate\\Foundation\\ComposerScripts::postInstall",
			"php artisan optimize"
		],
		"post-update-cmd": [
			"illuminate\\Foundation\\ComposerScripts::postUpdate",
			"php artisan optimize"
		],
	},
