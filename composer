Package
	- a (rather small) PHP library containing PHP source code
Packagist
	- is a repository for public PHP packages and is the default repo used by Composer
Composer
	- is a dependency manager
	- is used for autoloading (because it has its own autoloader)
	(- does compiler optimization)
	(- custom hooks into lifecycle events, such as application installed, updated, or first created)
	(- stability checking)
composer.json
	- is a file you create in the root directory of your project
	- you write the packages you want into this file, the version can be a range, e.g.: any version from 2.4.X to 3.X
	- you can write it manually or create it with: composer init
	
	a minimal composer.json only has to contain valid JSON: {}
	a more useful composer.json example which
		- defines the package "symfony/process" v3.3 or higher for the package in production mode and
		- "symfony/var-dumper" for the package in development mode
		- several other infos which are mainly used by packagist.org to catalog packages
		{
			"name": "me/mypackage",
			"description": "A package to play with Composer",
			"authors": [
				{
					"name": "michaelKaefer",
					"email": "michael.kaefer@something.at"
				}
			],
			"keywords": ["testing", "playing"],
			"license": "MIT",
			"require": {
				"symfony/process": "^3.3"
			},
			"require-dev": {
				"symfony/var-dumper": "^3.3"
			}
		}
Version rules
	exact versions				1.0.2
	ranges of valid versions	>	<2.0
					>=	>=1.0
					<	<1.1
					<=	<=1.0
					!=	!=1.0
					,	>=1.0,<2.0		, is like logical AND (defines multiple ranges)
					|	>=1.0,<1.1 | >=1.2	| is like logical OR
					, has higher precedence than |
	wildcard			*	1.0.*			equivalent of >=1.0,<1.1
	tilde operator			∼1.2				equivalent to >=1.2,<2.0.
composer.lock
	- is written automatically by Composer
	- contains all actually installed packages plus the exact version, e.g.: 2.6.13
composer install
	1. checks if the file "composer.lock" exists
	2.	- if it exists it reads it and installs the dependencies listed there
		- if not it does the same as "composer update"
composer update
	1. checks if the file "composer.json" exists
	2. reads the file and for every package it remembers the latest possible version 
	3. if the file exists it reads "composer.lock" and compares the remembered latest possible version from "composer.json" with the version currently installed
	4. if the remembered version is newer tha the one in "composer.lock" it installs the newer version
	5. creates or updates the file "composer.lock"
	
	--dev
		- braucht man nicht setzen: ist default und installiert auch alle packages unter "require-dev"
		- für die Produktivversion braucht man zB keine Tests und kann die Installation von "require-dev"-packages 
		ausschließen mit: --no-dev (diese Option löscht sogar alle zuvor installierten "require-dev"-packages 
		physisch vom Rechner)
2 Optionen, um ein package in einem Ordner (der noch keine Datei "composer.json" beinhaltet) zu installieren (man findet die verfügbaren freien packages bei Packagist):
	- manuell eine Datei "composer.json" erstellen und das package eintragen (zB unter "require") -> nicht so angenehm, eher die nächste Option wählen und das von Composer machen lassen
	- composer require [vendorname/packagename], Bsp: composer "require intervention/image"
		1. erstellt eine Datei "composer.json" und trägt das angegebene package unter "require" ein
		2. erstellt einen Ordner "vendor" (wenn nicht vorhanden)
		3. installiert die letzte Version des package im Ordner "vendor"
		4. erstellt eine Datei "composer.lock" und trägt dort das package (sowie dessen dependency-packages) ein, sowie die installierte Version des package
	dann:
		eine Datei, zB "index.php" erstellen und dort das package verwenden:
		index.php:
			<?php
			require 'vendor/autoload.php';
			use [namespace\path\to\classname];
			$var = [classname]::[method]([params]);
Autoloading
	...
Lifecycle hooks and scripts
	- Composer allows you to define commands which will be run after a specified event
	- for example after composer "create-project", "composer install", "composer update" etc.
	- e.g.: in Laravel you could run your migrations, clean up assets, etc. after every "composer install", so to get to production you only run "git pull ; composer install"
	
	"scripts": {
		"post-root-package-install": [
			"php -r \"file_exists('.env') || copy('.env.example', '.env');\""
		],
		"post-create-project-cmd": [
			"php artisan key:generate"
		],
		"post-install-cmd": [
			"illuminate\\Foundation\\ComposerScripts::postInstall",
			"php artisan optimize"
		],
		"post-update-cmd": [
			"illuminate\\Foundation\\ComposerScripts::postUpdate",
			"php artisan optimize"
		],
	},
